# nodejs-hw-mongodb

[text](<../Application file structure/src>)

Задание

Вам нужно создать приложение для работы с коллекцией контактов, в котором можно будет посредством HTTP запросов получать данные всех контактов или одного по id.

Файл с данными для загрузки:

contacts.json//https://drive.google.com/file/d/13baA584rRyDY8L_Axqi2Ii_qD9lUG-Hw/view

Критерии приема
Создано репозиторийnodejs-hw-mongodb
Задание выполнено на ветке hw2-mongodb
При сдаче домашней работы есть ссылки на исходные файлы Githubи ссылки на задеплоенный проект этой ДЗ (ветка hw2-mongodb) на render.com // https://render.com
При выполнении кода задачи нет ошибок

Пошаговое выполнение задания

Шаг 1
Инициализируйте проект командой npm init -y

Добавьте в зависимости от проекта eslint и подкорректируйте его конфигурационный файл согласно приведенному примеру в материалах 1го модуля в блоке “Файлы настроек”.

Добавьте в корень проекта файлы .gitignore и .prettierrc соответствующее содержимое.

Установите nodemon в качестве зависимости для разработки. Добавьте скрипт "dev" в файл package.json для запуска сервера с помощью nodemon. Для этого измените раздел scripts.
"lint": "eslint src//\*.js"\*\*:

ESLint — это инструмент для анализа кода, который помогает находить и исправлять проблемы в коде JavaScript.
src//\*.js\*\* указывает, что нужно проверить все файлы с расширением .js в папке src и во всех её подпапках.
Команда npm run lint выполнит ESLint для всех указанных файлов, что поможет обеспечить качество и консистентность кода, а также избежать ошибок.
"start": "node ./src/index.js":

node ./src/index.js запускает основной файл вашего приложения с помощью Node.js.
Команда npm start используется для запуска вашего приложения в продакшен-режиме.
"dev": "nodemon src/index.js":

Nodemon — это инструмент, который автоматически перезапускает приложение Node.js при изменении файлов в проекте.
src/index.js — это файл, который будет запущен и за которым будет следить nodemon.
Команда npm run dev запустит ваш проект в режиме разработки и будет перезапускать его каждый раз, когда вы вносите изменения в файлы, что значительно ускоряет процесс разработки.

Шаг 2

Создайте в корне проекта папку src.

В папке src создайте файл с именем server.js. В нем будет находиться логика работы вашего express-сервера.

В файле src/server.js создайте функцию setupServer, в которой будет создаваться express сервер. Эта функция должна включать в себя:

1.Создание сервера с помощью вызова express()
2.Настройка cors//https://www.npmjs.com/package/cors:
Пример настройки CORS для разрешения запросов только с определенного домена:
const corsOptions = {
origin: 'http://example.com', // Разрешает запросы только с указанного домена
methods: ['GET', 'POST'], // Разрешает только указанные методы
allowedHeaders: ['Content-Type', 'Authorization'], // Разрешает только указанные заголовки
};

app.use(cors(corsOptions));
и логгера pino//https://github.com/pinojs/pino-http .
Использовать pino-pretty
Команда разработки Pino создала аналогичный jq инструмент — pino-pretty — для преобразования строк JSON в удобочитаемый человеком обычный текст.//https://habr.com/ru/articles/737982/ or //https://github.com/pinojs/pino-pretty
npm install express cors pino-http pino-pretty dotenv
3.Обработку несуществующих роутов (возвращает статус 404 и ответное сообщение)
{
message: 'Not found', ,
}

Запуск сервера на порте, указанном через переменную окружения PORT или 3000, если такая переменная не указана
При удачном запуске сервера выводить в консоль строку “Server is running on port {PORT}”, где {PORT}это номер вашего порта
Не забудьте указать переменную окружения в файле.env.example

Создайте файл src/index.js. Импортируйте и вызовите в нем функцию setupServer.

Шаг 3

Создайте свой кластер в mongodb и функцию initMongoConnection для установления соединения с ней в отдельном файле src/db/initMongoConnection.js.

При создании кластера в MongoDB Atlas, не забудьте настроить доступ к сети, чтобы разрешить подключение с любого IP-адреса. Для этого выполните следующие шаги:

Войдите в свой аккаунт MongoDB Atlas и перейдите к своему проекту.
Выберите кластер или создайте новый.
Выделите раздел "Network Access".
Добавьте новую запись в список IP-адресов, нажав кнопку "+ ADD IP ADDRESS".
В появившемся окне выберите "ALLOW ACCESS FROM ANYWHERE" или введите 0.0.0.0/0в поле "Access List Entry". Это позволит подключение к вашему кластеру с любого IP-адреса.
При необходимости добавьте комментарий, затем нажмите "Confirm".

При удачном подключении к вашей базе mongodbвыводите в консоль строку "Mongo connection successfully established!".

Данные для подключения к базе должны быть вынесены в следующие переменные оцепления:
MONGODB_USER
MONGODB_PASSWORD
MONGODB_URL
MONGODB_DB
Укажите эти переменные окружения в файле.env.example
Для работы с mongodbиспользуйте пакет mongoose .

В файле src/index.js вызовите функции initMongoConnection. Убедитесь, что соединение с базой устанавливается до запуска сервера.

Mongoose — это библиотека для работы сMongoDB в среде Node.js. Она предоставляет простой способ моделирования и валидации данных MongoDB, а также удобный интерфейс выполнения запросов в базу данных. Установим ее в наше приложение соответствующей командой:npm install mongoose

Шаг 4

имя - строка, обязательная
phoneNumber — строка, обязательная
электронная почта - электронная почта, необязательно
isFavourite — логическое значение, по умолчанию false
contactType — строка, перечисление («работа», «дом», «личный»), обязательно, по умолчанию «личный»

Для автоматического создания полей createdAtи updatedAtможно использовать параметр timestamps: trueпри создании модели. Это добавляет к объекту два поля: createdAt(дата создания) и updatedAt(дата обновления), и их не нужно добавлять вручную.

контакты.json

Импортируйте базовый набор контактов из файла contacts.json в вашу базу, используя любой UI интерфейс (в браузере, Mongo Compass и т.п.). Убедитесь, что название коллекции в коде модели и визуальном интерфейсе совпадает.

Шаг 5

Создайте роут GET /contacts, который будет возвращать массив всех контактов. Обработка этого роута должна включать:

Регистрация роута в файлеsrc/server.js
Описание контроллера для этого роута
Создание сервиса в папке src/services в файле с соответствующим существом именем (в данном случае contacts.js)
Ответ сервера должен содержать объект со следующими свойствами:
status- статус ответа
message— уведомление о результате выполнения операции"Successfully found contacts!"
data- данные, полученные в результате обработки запроса

Шаг 6

Создайте роут GET /contacts/:contactId, который будет возвращать данные контакта по переданному ID или возвращать ошибку 404, если контакт не найден. Обработка этого роута должна включать:

Регистрация роута в файлеsrc/server.js
Описание контроллера для этого роута
Создание сервиса в папке src/servicesв файле с соответствующим именем сущности (в данном случае contacts.js)
Ответ сервера, если контакт найден, должен быть со статусом 200 и содержать объект со следующими свойствами:

{
status: 200 ,
сообщение: «Успешно найден контакт с идентификатором {**contactId**}!» ,
данные:
// об'єкт контакта
}

Добавьте проверку или контакт по переданному идентификатору был найден. Если контакт не найден, верните ответ с сатусом 404 и следующим объектом:

{
сообщение: «Контакт не найден» ,
}

На данном этапе не нужно проверять невалидный MongoDB ID в этом модуле. Предполагаем, что ID всегда валидный

Шаг 7

Задеплойте ваше приложение из ветки hw2-mongodbна render.com . Пошаговая инструкция как это сделать есть в этом видео:

Очень важно перед сдачей дзв на проверку ментору проверять работу вашего задеплоенного приложения на render.com !

Если, например, при деплое вы забыли добавить переменные оцепления (env), то задеплоенный бэкенд не будет работать. Также проверьте, что все созданные вами маршруты бэкенда работают, как ожидается в соответствии с заданием.

///
2.Задание

Вам необходимо продолжить создание приложения для работы с коллекцией контактов. Добавьте логику добавления новых контактов, удаления и редактирования существующих.

Критерии приема

Задание выполнено на веткеhw3-crud
При сдаче домашней работы есть ссылки на исходные файлыGithub и ссылки на задеплоенный проект этой ДЗ (ветка hw3-crud) на render.com
При выполнении кода задачи нет ошибок
При выполнении задания соблюдена файловая структура приложения, указанная в материалах курса

Пошаговое выполнение задания

Шаг 1

Создайте ветку hw3-crudиз ветки hw2-mongodbи выполняйте эту задачу в ветке hw3-crud.

Организуйте роутинг в вашем приложении:

вынесите код роутов из файла src/server.jsв файлsrc/routers/contacts.js
вынесите код контроллеров из файлаsrc/server.js в файлsrc/controllers/contacts.js

Шаг 2

Улучшите обработку ошибок в вашем приложении. Для этого:

Добавьте в зависимости от проекта пакет http-errors для обработки различных ошибок

Создайте в файле src/middlewares/errorHandler.jsи примените в файле src/server.jsmiddleware errorHandler, предназначенный для обработки ошибок в вашем Express-сервере. Этот middleware должен принимать четыре аргумента. errorHandlerв случае обнаружения ошибки должен отправить клиенту ответ со статусом 500 и объект со следующими свойствами:

{
status: 500 ,
message: "Something went wrong" ,
data:
// конкретное сообщение об ошибке, полученное с объекта ошибки
}

Создайте в файле src/middlewares/notFoundHandler.jsи примените в файле src/server.jsmiddleware notFoundHandler, предназначенный для обработки запросов, когда клиент обращается к несуществующему маршруту. notFoundHandlerв случае обнаружения ошибки с помощью http-errors создать ошибку со статусом 404 и сообщением "Route not found".

Создайте в файле src/utils/ctrlWrapper.jsи примените в файле src/routers/contacts.jsфункцию ctrlWrapper, которая будет действовать как обертка для контроллеров в вашем Express-приложении, для автоматической обработки ошибок, которые могут возникнуть при выполнении запросов. В этой обертке при возникновении ошибки вызовите next(err)для привлечения middlewareerrorHandler

Для роута GET /contacts/:contactIdесли контакт не был найден, с помощью http-errors создайте ошибку со статусом 404 и сообщением "Contact not found".

http-ошибки ( 404 , «Контакт не найден» )

Шаг 3

Создайте роут POST /contactsдля создания нового контакта. Тело запроса должно включать в себя следующие свойства:

name- Обязательно
phoneNumber- Обязательно
email- не обязательно
isFavourite- не обязательно
contactType - обовʼязково

Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/contacts.js
Описание контроллера для этого роута в файлеsrc/controllers/contacts.js
Создание сервиса в файлеsrc/services/contacts.js
Ответ сервера, в случае успешного создания нового контакта, должен быть со статусом 201 и содержать объект со следующими свойствами:

{
status: 201 ,
message: "Совершенно созданный contact!" ,
data:
// данные созданного контакта
}

Шаг 4

Создайте роут PATCH /contacts/:contactIdдля обновления данных существующего контакта. Тело запроса должно включать в себя следующие свойства:

name- не обязательно
phoneNumber- не обязательно
email- не обязательно
isFavourite- не обязательно
contactType- не обязательно

Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/contacts.js
Описание контроллера для этого роута в файлеsrc/controllers/contacts.js
Создание сервиса в файлеsrc/services/contacts.js
Ответ сервера, в случае успешного обновления данных контакта, должен быть со статусом 200 и содержать объект со следующими свойствами:
{
status: 200 ,
message: "Совершенно связано с поддержкой!" ,
data:
// обновленные данные контакта
}

Если контакт не найден, с помощью http-errors создайте ошибку со статусом 404 и сообщением "Contact not found"

http-ошибки ( 404 , «Контакт не найден» )

Шаг 5

Создайте роут DELETE /contacts/:contactIdдля удаления существующего контакта.

Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/contacts.js
Описание контроллера для этого роута в файлеsrc/controllers/contacts.js
Создание сервиса в файлеsrc/services/contacts.js
Ответ сервера, в случае успешного удаления контакта, должен быть со статусом 204 без тела ответа
Если контакт не был найден, с помощью http-errors ответ сервера должен быть со статусом 404 и сообщением "Contact not found".

http-ошибки ( 404 , «Контакт не найден» )

Шаг 6

Поменяйте ветку, из которой сейчас деплоится ваш проект на render.com . Убедитесь, что изменения успешно задеплоены

Очень важно перед сдачей дзв на проверку ментору проверять работу вашего задеплоенного приложения на render.com . Если, например, при деплое вы забыли добавить переменные оцепления (env), то задеплоенный бэкенд не будет работать. Также проверьте, что все созданные вами маршруты бэкенда работают, как ожидается в соответствии с заданием.

///////// 4 Задание ////////////

Вам необходимо продолжить создание приложения для работы с коллекцией контактов. Добавьте пагинацию, сортировку по имени, фильтрацию для коллекции контактов и валидацию входящих данных.

Критерии приема

Задание выполнено на веткеhw4-validation
При сдаче домашней работы есть ссылки на исходные файлыGithub и ссылки на задеплоенный проект этой ДЗ (ветка hw4-validation) на render.com
При выполнении кода задачи нет ошибок
При выполнении задания соблюдена файловая структура приложения, указанная в материалах курса

Пошаговое выполнение задания

Шаг 1

Создайте ветку hw4-validationиз ветки hw3-crudи выполняйте эту задачу в ветке hw4-validation.

Шаг 2

Улучшите обработку входных данных (валидацию) в вашем приложении. Для этого:

Создайте функцию validateBody, которая будет принимать аргументом схему валидации, а возвращать middleware для валидации body запроса.
Добавьте валидацию в роуты POST /contactsи PATCH /contacts/:contactId. Постройте схемы валидации, основываясь на том, как вы описали свойства модели MongoDB. Кроме того, для полей типа string добавьте правила минимальной длины - 3 символа и максимальной длины - 20 символов.
Добавьте middleware isValidId для проверки валидности ID и примените его во всех роутах, работающих с ID.

Шаг 3

Добавьте пагинацию к маршруту GET /contacts. Для этого используйте следующие параметры запроса:

page- номер страницы запроса (по умолчанию 1)
perPage- количество элементов на странице (по умолчанию 10)

Ответ сервера в свойстве dataдолжен содержать следующие свойства:

data- содержит массив контактов с текущей страницы
page- указывает номер текущей страницы
perPage- определяет количество элементов на странице
totalItems- указывает общее количество элементов в коллекции
totalPages- определяет общее количество страниц
hasPreviousPage- отображает предыдущая страница
hasNextPage- отображает ли следующая страница

Ответ сервера должен быть следующим форматом:

{
"статус" : 200 ,
"сообщение" : "Контакты успешно найдены!" ,
"data" : {
"data" : [ /* контакты */ ] ,
"page" : 2 ,
"perPage" : 4 , "
totalItems " : 6 ,
"totalPages" : 2 ,
"hasPreviousPage" : true ,
"hasNextPage " : ЛОЖЬ
}
}

Шаг 4

Добавьте возможность задать порядок сортировки элементов по имени контакта в ответе для маршрута GET /contacts. Для этого используйте следующие параметры запроса:

sortBy- определяет, по какому свойству нужно производить сортировку
sortOrder- определяет порядок сортировки ( asc- восходящий порядок сортировки (значение по умолчанию) или desc- нисходящий порядок сортировки)

Шаг 5 (не обязателен)

По желанию добавьте возможность фильтрации контактов по типу, свойству isFavouriteв ответе для маршрута GET /contacts. Для этого используйте следующие параметры запроса:

type- отображает тип контакта, значение свойстваcontactType
isFavourite- отображает контакт избранным

Шаг 6

Поменяйте ветку, из которой сейчас деплоится ваш проект на render.com , на hw4-validation. Убедитесь, что изменения успешно задеплоены

Очень важно перед сдачей дзв на проверку ментору проверять работу вашего задеплоенного приложения на render.com . Если, например, при деплое вы забыли добавить переменные оцепления (env), то задеплоенный бэкенд не будет работать. Также проверьте, что все созданные вами маршруты бэкенда работают, как ожидается в соответствии с заданием.


/////// Задание 5 /////

Вы научитесь:

внедрять регистрацию и аутентификацию пользователей с использованием хеширования паролей с помощью bcrypt.
использовать сессии и токены для обеспечения безопасности.
реализовывать middleware для аутентификации пользователей.
использовать cookies для хранения и передачи токенов.
ограничивать доступы к данным пользователям при определенных условиях.


Эта задача поможет вам овладеть ключевыми концепциями аутентификации и авторизации в Node.js, а также изучить эффективные практики работы с базами данных и обеспечения безопасности веб-приложений. Так что не теряй время — Go практиковаться! 🚀



Задание



Вам необходимо продолжить создание приложения для работы с коллекцией контактов. Разместите коллекцию пользователей и соответствующие роуты для работы с ней: регистрация, логин, логаут и рефреш. Дополните логику существующих контактов роутов аутентификацией.



Критерии приема



Задание выполнено на веткеhw5-auth
При сдаче домашней работы есть ссылки на исходные файлыGithub и ссылки на задеплоенный проект этой ДЗ (ветка hw5-auth) на render.com
При выполнении кода задачи нет ошибок
При выполнении задания соблюдена файловая структура приложения, указанная в материалах курса


Пошаговое выполнение задания



Шаг 1



Создайте ветку  hw5-authиз ветки  hw4-validationи выполняйте эту задачу в ветке hw5-auth.



Шаг 2



Создайте модель Userсо следующими полями:

name- строка, обязательна
email- строка, адрес электронной почты, уникальный, обязательный
password- строка, обязательна
createdAt- дата создания
updatedAt- дата обновления


Создайте модель Sessionсо следующими полями:

userId- строка, обязательна
accessToken- строка, обязательна
refreshToken- строка, обязательна
accessTokenValidUntil- Дата, обязательно
refreshTokenValidUntil- Дата, обязательно


Шаг 3



Создайте роут POST /auth/registerдля регистрации нового пользователя. Тело запроса должно включать в себя следующие свойства:

name- обязательно
email- обязательно
password- обязательно (помните, что пароль должен быть закрыт с помощью библиотеки bcrypt)


Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/auth.js
Валидацию полученных данных
Описание контроллера для этого роута в файлеsrc/controllers/auth.js
Создание сервиса в файлеsrc/services/auth.js
Убедитесь, что пользователь с такой почтой еще не существует в системе, верните с помощью библиотекиcreateHttpError 409 ошибку в противном случае и сообщение 'Email in use'.
Ответ сервера, в случае успешного создания нового пользователя, должен быть со статусом 201 и содержать объект со следующими свойствами:
status- статус ответа
message— уведомление о результате выполнения операции"Successfully registered a user!"
data— данные созданного пользователя (должно отсутствовать поле с паролем!)


Шаг 4



Создайте роут POST /auth/loginдля проверки подлинности пользователя. Тело запроса должно включать в себя следующие свойства:

email - обовʼязково
password- обовʼязково


Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/auth.js
Валидацию полученных данных
Описание контроллера для этого роута в файлеsrc/controllers/auth.js
Создание сервиса в файлеsrc/services/auth.js
Убедитесь, что пользователь с такой почтой и паролем существует в системе, поверните с помощью библиотекиcreateHttpError 401 ошибку в противном случае.
Если пользователь по переданным данным был найден, то создайте для него сессию, в которую запишите сгенерированные access и refresh токены. Старая сессия при ее наличии должна быть удалена. Укажите время жизни 15 мин для access токена и 30 дней для refresh токена.
Запишите рефреш токен в cookies, а access токен верните в теле ответа.
Ответ сервера, в случае успешного создания нового контакта, должен быть со статусом 200 и содержать объект со следующими свойствами:
status- статус ответа
message— уведомление о результате выполнения операции"Successfully logged in an user!"
data- объект со свойством accessToken, содержащий значение созданного access токена




Шаг 5



Создайте роут POST /auth/refreshдля обновления сессии на основе рефреш токена,

который записан в cookies.



Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/auth.js
Описание контроллера для этого роута в файлеsrc/controllers/auth.js
Создание сервиса в файлеsrc/services/auth.js
Предварительная сессия, при ее наличии, должна быть удалена, а новая создана по тому же принципу, что и в POST/auth/login .
Ответ сервера, в случае успешного создания нового контакта, должен быть со статусом 200 и содержать объект со следующими свойствами:
status- статус ответа
message— уведомление о результате выполнения операции"Successfully refreshed a session!"
data- объект со свойством accessToken, содержащий значение вновь access токена


Шаг 6



Создайте роут POST /auth/logoutдля удаления сессии на основе ID сессии и токена, который записан в cookies.

Обработка этого роута должна включать:

Регистрация роута в файлеsrc/routers/auth.js
Описание контроллера для этого роута в файлеsrc/controllers/auth.js
Создание сервиса в файлеsrc/services/auth.js
Текущая сессия должна быть удалена.
Ответ сервера, в случае успешного логаута, должен со статусом 204, без тела ответа.


Шаг 7



Создайте middleware authenticate, который будет основан на access токена из заголовка Authorization в виде Bearer-токена, определять пользователя и добавлять его к объекту запроса( req) в виде свойства user. При этом убедитесь, что access токен не просрочен, иначе с помощью библиотеки createHttpErrorверните ошибку со статусом 401 и сообщением “Access token expired”.



Примените этот middleware для всех контактов роутов.
// export const authenticate = async (req, res, next) => {
//   const authHeader = req.get('Authorization');

//   if (!authHeader) {
//     next(createHttpError(401, 'Auth header should be of type Bearer'));
//     return;
//   }

// const [bearer, token] = authHeader.split(' ');

//   if (bearer !== 'Bearer' || typeof token !== 'string') {
//     next(createHttpError(401, 'Access token expired'));
//     return;
//   }

//   const session = await Session.findOne({ accessToken: token });

//   if (!session) {
//      return next(createHttpError(401, 'Session not found'));

//   }

//   const isAccessTokenExpired =
//     new Date() > new Date(session.accessTokenValidUntil);

//   if (isAccessTokenExpired) {
//      return next(createHttpError(401, 'Access token expired'));
//   }

//   const user = await User.findById(session.userId);

//   if (user === null) {
//     next(createHttpError(401, 'User not found'));
//     return;
//   }

//   req.user = user;

//   next();
// };


Шаг 8



Расширьте модель Contactобязательным полем userId, указывающим на принадлежность контакта определенному пользователю.

Измените логику роута POST /contacts, чтобы при создании нового контакта также добавлялось поле userId. Для userIdвозьмите значение req.user._id.

Также измените логику для всех других роутов, работающих с коллекцией контактов, чтобы пользователи могли работать только с собственными контактами. Для этого в сервисных функциях используйте методы Mongoose такие как find(), findOne()и т.д., чтобы иметь возможность искать контакты помимо прочего и по значению свойства userId.



Шаг 9



Поменяйте ветку, из которой сейчас деплоится ваш проект на render.com , на hw5-auth. Убедитесь, что изменения успешно задеплоены.

////// Задание 6 //////

Поздравляем!

Это уже шестое домашнее задание по курсу Node.js. В этой задаче мы реализуем функционал для восстановления пароля и добавим возможность загружать изображения для студентов. Мы будем использовать сервисы Brevo и Cloudinary для управления электронной почтой и изображениями соответственно.



Вы научитесь:

внедрять функционал для сброса пароля с использованием токенов.
использовать сервис Brevo для отправки сообщений по электронной почте.
интегрировать загрузку изображений с использованием сервиса Cloudinary.
расширять модели и эндпоинты для поддержания новых функциональностей.


Эта задача поможет вам овладеть новыми концепциями работы с электронной почтой и изображениями в Node.js, а также изучить эффективные практики работы с внешними сервисами.

Так что не теряй время — Go практиковаться! 🚀



Задание



Критерии приема

Задание выполнено на веткеhw6-email-and-images
При сдаче домашней работы есть ссылки на исходные файлы Githubи ссылки на задеплоенный проект этой ДЗ (ветка hw6-email-and-images) на render.com
При выполнении кода задачи нет ошибок
При выполнении задания соблюдена файловая структура приложения, указанная в материалах курса


Пошаговое выполнение задания



Шаг 1

Создайте ветку hw6-email-and-imagesиз ветки hw5-authи выполняйте эту задачу в ветке hw6-email-and-images.



Шаг 2

Создайте аккаунт на brevo.com . Этот сервис будет использован для отправки сообщений по электронной почте.



Шаг 3

Создайте роут POST /auth/send-reset-email. В body он должен принимать имейл пользователя (свойство email).

С помощью пакета nodemailer(используйте кредиты из Brevo для подключения к SMTP-серверу) организуйте отправку емейла пользователю со ссылкой на сброс пароля.

Ссылка должна состоять из:

Домена, на котором будет находиться фронтенд нашего приложения (взять из переменных окружающих);
Пути к странице со сбросом пароля - /reset-password;
Query-параметру token, который равен JWT токену, созданному на бэкенде и содержащему email пользователя. Срок жизни токена установите 5 минут.


Общая ссылка будет выглядеть так:

https ://<ваш-домен-интерфейса>/reset-password? токен =<jwt- токен >

На этом этапе все чувствительные данные должны быть вынесены в переменные оцепления.



Данные для подключения к Brevo:

SMTP_HOST
SMTP_PORT
SMTP_USER
SMTP_ПАРОЛЬ
SMTP_FROM (значением должна быть почта, на которую регистрировали аккаунт на brevo.com)


Переменная, которая будет использоваться для генерации подписи нашего токена:

JWT_SECRET (значение произвольное, например, VOQjLdrpG1TWCHhDzv3o)


Домен, на котором находится фронтенд нашего приложения:

APP_DOMAIN (пока можно использовать со значением “ http://localhost:3000/auth” )
Обязательно добавьте эти переменные окружения в файл .env.example.


Обработайте такие ошибки как:

ошибка валидации body (используйте middleware validateBody);
отсутствует пользователь в базе (с помощью  http-errors  создайте ошибку со статусом 404 и сообщением "User not found!");
не удалось отправить письмо (с помощью  http-errors  создайте ошибку со статусом 500 и сообщением "Failed to send the email, please try again later.").


В случае успешной отправки сообщения ответ сервера должен быть со статусом 200 и содержать объект со следующими свойствами:

   { 
       status:  200 ,
        сообщение:  «Письмо для сброса пароля успешно отправлено». ,
        данные:  { } 
   }



Шаг 4



Создайте роут POST /auth/reset-pwd.

В body он должен принимать:

свойство token- JWT токен, который был передан в ссылку для сброса пароля в предыдущем шаге;
свойство password– новый пароль.
Убедитесь, что полученный в body JWT токен действителен и не просрочен.



Обработайте такие ошибки как:

ошибка валидации body (используйте middleware validateBody);
отсутствует пользователь в базе (с помощью  http-errors  создайте ошибку со статусом 404 и сообщением "User not found!");
просроченный или поврежденный токен (передайте к вызову createHttpErrorстатус 401 и сообщение "Token is expired or invalid.").


Если с токеном все хорошо, то для пользователя с email, содержащимся в токене:

обновите пароль;
удалите текущую сессию для этого пользователя.


В случае успешной замены пароля ответ сервера должен со статусом 200 и содержать объект со следующими свойствами:

   { 
       status:  200 ,
        сообщение:  «Пароль успешно сброшен». ,
        данные:  { } 
   }



Шаг 5

Зарегистрируйтесь на Cloudinary .



Шаг 6

Расширьте функционал возможностью загружать фотографии для роутов:

ПОЧТА/contacts
ПЛАСТЫРЬ/contacts/:contactId
Добавьте поддержку Content-Type: multipart/formdata для этих эндпоинтов.
Добавьте поле photoтипа String в модели Contact.
Добавьте загрузку файлов на cloudinary . Ссылку на файл фото запишите в базу в поле photo. Убедитесь, что во всех эндпоинтах, где есть работа с контактами, есть возможность получить ссылки на фото.


Шаг 7

Поменяйте ветку, из которой сейчас деплоится ваш проект на render.com , на hw6-email-and-images. Убедитесь, что изменения успешно задеплоены.

Эта задача поможет создать удобный и безопасный механизм для работы с пользовательскими паролями и загрузкой изображений. Удачи в выполнении задания! 🚀



Очень важно перед сдачей дзв на проверку ментору проверять работу вашего задеплоенного приложения на render.com . Если, например, при деплое вы забыли добавить переменные оцепления (env), то задеплоенный бэкенд не будет работать. Также проверьте, что все созданные вами маршруты бэкенда работают, как ожидается в соответствии с заданием.